#!/usr/bin/env bash
### Computational Biology Core (http://cbc.ucsf.edu) C4 Toolkit
###
### Usage:
###  c4 <command> [options]
###
### Commands:
###
### Example:
###  c4 status              - Cluster status
###  c4 nodes               - List nodes that are up
###  c4 users               - List all users
###  c4 ps --node head      - List all processes on the head node
###  c4 ps --node n6        - List all processes on node n6
###  c4 head                - List users' usage of head node
###  c4 disk_usage          - Summarize a users disk usage
###  c4 delete_sam_with_bam - Delete SAM files with existing (newer) BAM file
###
### How to install:
### Add the following to your ~/.bashrc script:
###  source ${SHARED_ROOT}/bashrc

if test -z "$SHARED_SOFTWARE"; then
  source /home/shared/cbc/bashrc
fi

cmd=$1
if test "$cmd" == ""; then
    cmd="help"
fi

shift

HEAD_NODE="cclc01.som.ucsf.edu"
CLUSTER_NODES=$(bpstat -l | tail -n +2 | cut -c 1-4 | sed -e 's/ //g')
CLUSTER_NODES_UP=$(bpstat -l | tail -n +2 | grep -F up | cut -c 1-4 | sed -e 's/ //g')
CLUSTER_NODES_DOWN=$(bpstat -l | tail -n +2 | grep -F down | cut -c 1-4 | sed -e 's/ //g')

TMPDIR=/tmp/$USER/.c4
mkdir -p $TMPDIR

dryrun=FALSE
all=FALSE
full=FALSE
force=FALSE
verbose=FALSE
clean=FALSE
class=
action=

## All nodes that are up
nodes=
for n in $CLUSTER_NODES_UP; do nodes="$nodes n$n"; done

## Identify all users on the cluster
users=($(cat /etc/passwd | grep -F "/home/" | grep -E "(@|inactive)" | cut -d':' -f1 | sort -u))

while [[ $# > 0 ]]; do
    opt=$1
    if test "$opt" == "--nodes"; then
        nodes=$2
        shift
    elif test "$opt" == "--node"; then
        nodes=$2
        shift
    elif test "$opt" == "--users"; then
	users=($(echo $2 | sed 's/,/ /g'))
	all=TRUE
	shift
    elif test "$opt" == "--user"; then
	users=($(echo $2 | sed 's/,/ /g'))
	shift
    elif test "$opt" == "--me"; then
	users=($USER)
	shift
    elif test "$opt" == "--all"; then
	all=TRUE
    elif test "$opt" == "--clean"; then
	clean=TRUE
    elif test "$opt" == "--class"; then
        class=$2
	shift
    elif test "$opt" == "--action"; then
        action=$2
        shift
    elif test "$opt" == "--full"; then
        full=TRUE
    elif test "$opt" == "--verbose"; then
        verbose=TRUE
    elif test "$opt" == "--dry-run"; then
        dryrun=TRUE
    elif test "$opt" == "--force"; then
        force=TRUE
    fi
    shift
done


if test $cmd == "help"; then
    grep "^###" $0 | grep -v "^####" | cut -b 5- | sed -e "s#\${SHARED_ROOT}#$SHARED_ROOT#g"
elif test $cmd == "status"; then
    echo "# Cluster status"
    echo
    echo "## Nodes"
    bpstat
    echo
    echo "## Disk space"
    df -h | grep -E "(Filesystem|home|data|work)"
    echo
    echo "## Job scheduler"
    echo "There are `qstat -t -n -1 | grep -E "^[0-9]+" | wc -l` cluster jobs of which `qme | grep -E "^[0-9]+" | wc -l` are yours (see 'qstat' and 'qme')"
    if test $HOST == $HEAD_NODE; then
	echo "Moab status: $(service moab status)"
        echo
        echo "## Head-Node Status"
        echo
        echo "### High-memory non-user processes"
        printf "USER\tPID\t%%CPU\t%%MEM\tPROCESS\n"
        $0 ps --node head | grep -vE "^USER" | grep -v -E "($(echo ${users[@]} | sed 's/ /|/g'))" | awk '{printf "%s\t%s\t%s\t%s\t%s\n", $1, $2, $3, $4, $11}' | sort --key=4 -r -n | head -5
        echo
        echo "### High-CPU non-user processes"
        printf "USER\tPID\t%%CPU\t%%MEM\tPROCESS\n"
        $0 ps --node head | grep -vE "^USER" | grep -v -E "($(echo ${users[@]} | sed 's/ /|/g'))" | awk '{printf "%s\t%s\t%s\t%s\t%s\n", $1, $2, $3, $4, $11}' | sort --key=3 -r -n | head -5
        echo
    else
	echo "NOTE: Moab status and memory & CPU profiling is only available from the head node."
    fi
elif test $cmd == "nodes"; then
    echo "Cluster nodes (that are up): $(echo $CLUSTER_NODES_UP)"
elif test $cmd == "checknodes"; then
    echo "Cluster nodes: $(echo $CLUSTER_NODES)"
    echo "Cluster nodes (that are up): $(echo $CLUSTER_NODES_UP)"
    echo "Cluster nodes (that are down): $(echo $CLUSTER_NODES_DOWN)"    
    for node in $CLUSTER_NODES; do
	printf "Node n$node: "
	status=$(/opt/moab/bin/checknode n$node | grep State: | sed 's/State: *//g')
	echo "$status"
    done
elif test $cmd == "users"; then
    if test $clean == "TRUE"; then
      echo "${users[@]}"
    else
      echo "Cluster users: [n=${#users[@]}] ${users[@]}"
    fi
elif test $cmd == "ps"; then
    nodesT=$(echo $nodes | sed 's/n//g' | sed -E 's/(,| )/|/g' | sed -E 's/(head|-1)/ /g')
    bfr=$(ps uax | bpstat -P)
    hdr=$(printf '%s\n' "${bfr[@]}" | head -1 | sed -E 's/^NODE[ ]*//g')
    res=$(printf '%s\n' "${bfr[@]}" | grep -E "^($nodesT)[ ]+")
    printf '%s\n' "${hdr[@]}"
    printf '%s\n' "${res[@]}"
elif test $cmd == "head"; then
    if test $HOST != $HEAD_NODE; then
	echo "ERROR: c4 head is only supported on the head node ($HEAD_NODE): $HOST"
	exit 1
    fi

    hdr=$(ps uax | bpstat -P | head -1 | sed -E 's/^NODE[ ]*//g')
    bfr=$(ps uax | bpstat -P | grep -E "^  " | grep -E -v "^[ ]+root" | sed -E 's/^[ ]*//g' | grep -E -v "$USER .* (ps uax|grep -E |.*c4 head|sed -E)")
    if test $full == "FALSE"; then
        bfr=$(printf '%s\n' "${bfr[@]}" | grep -v -E "( |-|/)(top|watch|qdel|qsub|qstat|bpstat|bash|dbus-daemon|dbus-launch|zsh|tcsh|git|git-credential-cache--daemon|ssh|ssh-agent|sshd|sftp-server|mosh-server|SCREEN|screen|tmux|c4|less|emacs|vim|nano|top|htop)( |:|$)")

	## HB's Cron jobs (calling this method)
        bfr=$(printf '%s\n' "${bfr[@]}" | grep -v -E "scan-c4_head")
	
	## Nextflow (http://www.nextflow.io/)
        bfr=$(printf '%s\n' "${bfr[@]}" | grep -v -E "java .* [-]Dcapsule[.]app=nextflow")
    fi

    for user in ${users[@]}; do
	uid=$(id -u $user)
	res=$(printf '%s\n' "${bfr[@]}" | grep -E "^($user|$uid) " | grep -v "grep -E \"$user \"")
        if test "${res[@]}" == ""; then
            if test $full == "TRUE"; then
                user_info=$(grep -E "^$user:" /etc/passwd | cut -d: -f5)
                echo "$user [$user_info, UID $uid]:"
	    fi
	else 
            user_info=$(grep -E "^$user:" /etc/passwd | cut -d: -f5)
            echo "$user [$user_info, UID $uid]:"
	    pids=$(printf "${res[@]}" | sed -E 's/^[ ]*[^ ]+[ ]+([0-9]+)[ ]+.*/\1/g' | grep -E "[0-9]+")
	    pids="${pids[@]}"
            printf "PIDs (on the head node): "
	    echo ${pids}
	    printf '%s\n' "${hdr[@]}"
	    printf '%s\n' "${res[@]}"
	    echo
	fi
    done    
elif test $cmd == "disk_usage"; then
    if test ${#users[@]} -gt 1 && test "$all" == "FALSE"; then
	echo "ERROR: Did you forget --me or --user <user>?  If you wish to apply for multiple users, please confirm by specifying --all"
	exit 1
    fi
    for user in ${users[@]}; do
      user_info=$(grep -E "^$user:" /etc/passwd | cut -d: -f5)
      echo "$user [$user_info]:"
      for path in $(eval echo ~$user) /data/$user/ /work/$user/; do
	  if test -d $path; then
	      du -sh $path
	  fi
      done
      echo
    done
elif test $cmd == "find_sam_with_bam"; then
    echo "Searching for SAM files with a newer BAM files"
    echo "Path (recursively): $(pwd)"
    find . -type f -iname "*.sam" | sort -u > $TMPDIR/sam.txt
    ## Any SAM files found
    if [[ -s $TMPDIR/sam.txt ]]; then
      find . -type f -iname "*.bam" | sed 's/[.]bam$/.sam/g' | sort -u > $TMPDIR/bam_sam.txt
      files=$(comm -1 -2 $TMPDIR/sam.txt $TMPDIR/bam_sam.txt)
      rm $TMPDIR/sam.txt $TMPDIR/bam_sam.txt
      sams=()
      for sam in $files; do
  	bam=${sam/sam/bam}
  	if [[ -f "$bam" && "$bam" -nt "$sam" ]]; then
  	    sams=($sams $sam)
  	fi
      done
      if [[ ${#sams[@]} -gt 0 ]]; then
          echo
  	for sam in $sams; do
              if [[ $full == "TRUE" ]]; then
                  bam=${sam/sam/bam}
  	        ls -rtl --time-style=long-iso $sam $bam
  	    else
  	      echo $sam
  	    fi
  	    if [[ $action == "delete" ]]; then
  echo	      rm "$sam"
  	    fi
  	done
          if [[ $action != "delete" ]]; then
  	    echo
              echo "Use '--action delete' to delete these"
          fi
      else
        echo "No SAM files with matching BAM files found."
      fi
    else
      echo "No SAM files found."
    fi
    echo
elif test $cmd == "large_files"; then
    if test ${#users[@]} -gt 1 && test "$all" == "FALSE"; then
	echo "ERROR: Did you forget --me or --user <user>?  If you wish to apply for multiple users, please confirm by specifying --all"
	exit 1
    fi
    echo "Cluster users: [n=${#users[@]}] ${users[@]}"

    exts=()
    if test "$class" == "htseq"; then
	exts=("pileup" "mpileup" "fastq" "fq" "sam")
    elif test "$class" == "text"; then
	exts=("txt")
    else
	echo "ERROR: --class <class> is missing."
	exit 1
    fi

    minsize=50000k
    minsize=500
    opts="-size +$minsize"
    
    echo "File extensions considered: ${exts[@]}"
    opts="$opts -name 'DUMMY_DUMMY_DUMMY'"
 #   for ext in ${exts[@]}; do
#	opts="$opts -o -name '*.$ext'"
 #   done


    if test "$action" == "list"; then
        echo "find options: $opts"
        find . -type f ${opts} -exec ls -lh {} \; | awk '{ print $9 ": " $5 " (" $6 " " $7 " " $8 ")" }'
#        find . -type f $opts -exec ls -lh {} \; | awk '{ print $9 ": " $5 " (" $6 " " $7 " " $8 ")" }'
    elif test "$action" == "gzip"; then
        echo "find options: $opts"
        find . -type f $opts ! -f '*.gz' -exec gzip
    else
	echo "ERROR: --action <action> is missing."
	exit 1
    fi
elif test $cmd == "apply"; then
    echo "Nodes to be called: $(echo $nodes)"
    node_cmd="$*"
    echo "Command applied to each node: '$node_cmd'"
    if test -z "$node_cmd"; then
      echo "ERROR: Missing command to be called on each node"
      exit -1
    fi
    for node in $nodes; do
	echo NODE $node:
	call="ssh $node $node_cmd"
	echo $call
	if test "$dryrun" == "TRUE"; then $call; fi
	echo
    done
elif test $cmd == "sync-to-scratch"; then
    srcdir=$(eval echo ~$USER)/cluster/scratch/
    destdir=/scratch/$USER/

    if test $HOST == "HEAD_NODE"; then
	echo "ERROR: Trying to sync $srcdir to local disk on the head node."
	exit 1
    fi

    if test ! -d "$srcdir"; then
	echo "WARNING: Cannot sync $srcdir to $destdir on local disk on compute node $HOST, because source directory does not exist. Skipping."
	exit 1
    fi

    mkdir -p $destdir

    xopts=
    if test -n "$dryrun" == "TRUE"; then xopts="$xopts --dry-run"; fi
    
    call="rsync -vLropgtD --delete --exclude='*~' --exclude='*.bak' --exclude='*.log' --exclude='*.out' --exclude='*.err' --exclude='*.logs/' --exclude='*.HIDE*/' --exclude=downloads/ --exclude=.async/ $xopts $srcdir $destdir"
    echo "Node: $HOST"
    echo "Command: $call"
    $call
elif test $cmd == "software"; then
  echo "** Software in $SHARED_SOFTWARE/:"
  ls $SHARED_SOFTWARE | grep -v "~$"
elif test $cmd == "utils"; then
  echo "** Command-line utilities in $SHARED_BIN/:"
  ls $SHARED_BIN | grep -v "~$"
elif test $cmd == "aliases"; then
  echo "** Aliases set by $SHARED_ROOT/bashrc:"
  grep "^alias" $SHARED_ROOT/bashrc | grep -v "alias git" | sort -u
elif test $cmd == "functions"; then
  echo "** Functions defined in bashrc and bin/* in $SHARED_ROOT/:"
  cat $SHARED_ROOT/bashrc $SHARED_BIN/* | grep "^function" | sed 's/ {//g' | sort -u
  echo
  echo "To see a function definition, use type <fcn>, e.g. type timestamp"
elif test $cmd == "envvars"; then
  echo "** Environment variable set by $SHARED_ROOT/bashrc:"
  grep "^export" $SHARED_ROOT/bashrc | cut -b 8- | cut -d = -f 1 | sort -u
elif test $cmd == "motd"; then
  cat /etc/motd
fi


# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
# HISTORY:
# 2015-06-24
# o Added --cluster
# 2014-12-23
# o Added --motd
# 2014-10-06
# o Added --functions
# 2014-10-05
# o Created by Henrik Bengtsson.
# - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -





