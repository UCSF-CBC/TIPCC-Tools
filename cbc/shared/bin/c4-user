#!/usr/bin/env bash
### UCSF C4 Toolkit:
### Detailed user information
###
### Usage:
###  c4-user [options]
###
### Options:
###  --list              List all users
###
###  --user <user>       Specify user (default: \$USER)
###
###  --jobs              List cluster jobs / tasks
###  --head              List head-node processes
###  --disk-usage        List disk usage (slow)
###  --all               As --jobs --head --disk-usage
###  --most              As --all without --disk-usage
###
###  --help              This help
###
### Example:
###  c4-user
###  c4-user --user alice
###
### Version: 0.1.0-9000
### Copyright: Henrik Bengtsson (2016-2017)
### License: GPL (>= 2.1) [https://www.gnu.org/licenses/gpl.html]
call="$0 $*"
tool_name=$(basename $0)
if [[ ${C4_TOOLS} -ne 0 ]]; then
    tool_name=${tool_name/-/ }
    shift
fi

function mecho() { echo "$@" 1>&2; }

function merror() {
    mecho "ERROR in '${tool_name}': $*"
    exit 1
}

function as_logical() {
    if [[ $1 == "false" || $1 == "0" ]]; then echo 0; else echo 1; fi
}

function help() {
    local res=$(grep -E "^###( .*|)$" $0 | cut -b 5-)
    local search=$(basename $0)
    if [[ "${search}" != "${tool_name}" ]]; then
        res=$(printf '%s\n' "${res[@]}" | sed "s/${search}/${tool_name}/g")
    fi
    printf '%s\n' "${res[@]}"
}

function whatis() {
    local res=$(grep "^### .*[^:][[:space:]]*$" $0 | head -1 | cut -b 5-)
    printf '%s\n' "${res[@]}"
}

function version() {
    grep -E "^###[ ]*Version:[ ]*" $0 | sed 's/###[ ]*Version:[ ]*//g'
}

## Cluster functions
function on_compute_node() {
    if [[ -z ${ISCOMPUTENODE+x} ]]; then
        pbsnodes ${HOSTNAME} &> /dev/null
        if [[ $? -eq 0 ]]; then echo 1; else echo 0; fi
    else
	echo $(as_logical ${ISCOMPUTENODE})
    fi
}

function all_users() {
  cat /etc/passwd | grep -F "/home/" | grep -E "(@|inactive)" | cut -d':' -f1 | sort -u
}

function user_info() {
    local user=$1
    local uid=$(id -u $user)
    local info=$(grep -E "^$user:" /etc/passwd | cut -d: -f5)
    local groups=$(groups $user | sed 's/.*:[ ]*//g')
    echo "$user [$info, UID $uid, GROUPS $groups]:"
}

user=${USER}
moab=1
jobs=1
head=1
disk_usage=0

# Parse command-line options
while [[ $# > 0 ]]; do
    if [[ "$1" == "--help" ]]; then
        help
        exit 0
    elif [[ "$1" == "--whatis" ]]; then
        whatis
        exit 0
    elif [[ "$1" == "--version" ]]; then
        version
        exit 0
    elif [[ "$1" == "--user" ]]; then
        shift
        user=$1
    elif [[ "$1" == "--list" ]]; then
        all_users
	exit 0
    elif [[ "$1" == "--me" ]]; then
        user=${USER}
    elif [[ "$1" == "--jobs" ]]; then
        jobs=1
    elif [[ "$1" == "--head" ]]; then
        head=1
    elif [[ "$1" == "--disk-usage" ]]; then
        disk_usage=1
    elif [[ "$1" == "--moab" ]]; then
        moab=1
    elif [[ "$1" == "--most" ]]; then
        jobs=1
        head=1
        moab=1
    elif [[ "$1" == "--all" ]]; then
        jobs=1
        head=1
        moab=1
        disk_usage=1
    else
        user=$1
    fi
    shift
done

filter=$(as_logical $filter)

## Assert running on head node
#if [[ $(on_compute_node) -ne 0 ]]; then
#    merror "This command only works on the head node: ${HOSTNAME}"
#fi


## Identify user
id=$(id $user 2> /dev/null)

## No such user?
if [[ $? -ne 0 ]]; then
    ## Maybe the email address and the personal name was specified?
    ## Try free-text search the 'name (email)' field of /etc/passwd
    info=$(cut -d: -f5 /etc/passwd | grep -F $user)

    ## No match?
    if [[ $? -ne 0 ]]; then
        merror "No such user (also searched person's name and email address): '${user}'"
    fi
    
    ## Multiple matches?
    ncount=$(printf '%s\n' "${info[@]}" | wc -l)
    if [[ ${ncount} != 1 ]]; then
        printf '%s\n' "${info[@]}" 1>&2;
        merror "Found ${ncount} matches. Please use a more specific search string: '${user}'"
    fi

    ## Extract 'user' information for the unique match
    line=$(cut -d: -f5 /etc/passwd | grep -n -F $user | cut -d: -f1)
    user=$(sed "${line}q;d" /etc/passwd | cut -d: -f1)

    ## Re-assert user exists (should always work)
    id=$(id $user 2> /dev/null)
    if [[ $? -ne 0 ]]; then   
        merror "No such user: $user"
    fi
fi

if [[ $? -ne 0 ]]; then   
    merror "No such user: $user"
fi


## Display user information
info=$(grep -E "^$user:" /etc/passwd | cut -d: -f5)
fullname=$(echo $info | sed 's/[ ]*[(].*//')
email=$(echo $info | sed -E 's/.*[(](.*)[)]/\1/')
home=$(grep -E "^$user:" /etc/passwd | cut -d: -f6)
shell=$(grep -E "^$user:" /etc/passwd | cut -d: -f7)


## Information about user
echo "Username        : $user"
echo "UID             : $(id -u $user)"
echo "Groups          : $(id $user | sed 's/.*groups=//' | sed 's/,/, /g')"
echo "Primary group   : $(id -gn $user)"
echo "Name            : $fullname"
echo "Email           : $email"
echo "Home directory  : $home"
echo "Shell           : $shell"
echo "Last login      : $(finger $user | grep -E '(Last login|On since)' | sed 's/Last login *//g' | head -1)"

## Moab information
if [[ $moab -eq 1 ]]; then
    pattern="($(id -Gn $user | sed 's/ /|/g'))"
    grep -qE "(${pattern})" /opt/moab/etc/moab.cfg
    res=$(grep -E "(${pattern})" /opt/moab/etc/moab.cfg | grep -vE "^#" | grep -vE '^[[:space:]]*$' | sed 's/^/ - /g')
    if [[ -z "${res[@]}" ]]; then
        echo "Moab privileges : <none>"
    else
        echo "Moab privileges :"
        printf '%s\n' "${res[@]}"
    fi
fi

## Jobs
if [[ $jobs -eq 1 ]]; then
    echo "Cluster tasks   : $(qme --user $user | grep -F "Number of tasks:" | sort -u | sed 's/Number of tasks: //g')"
fi

## Head-node processes
if [[ $head -eq 1 ]]; then
    res=$(c4-head --user $user | grep -E "^PIDs" | sed 's/.*: //g')
    if [[ $(echo $res | grep -E "^PIDs:") ]]; then
        echo "Head node PIDs  : $res"
    else
        echo "Head node PIDs  : <none>"
    fi
fi

## Disk usage
if [[ $disk_usage -eq 1 ]]; then
    echo "Disk usage      :"
    for path in $home /data/$user/ /work/$user/; do
       printf " - "
       if [[ -d $path ]]; then
           du -sh $path
       fi
    done
    echo
fi


